using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Windows.Forms;
using System.IO;
using System.Drawing;

namespace LHON_Form
{
    public partial class Main_Form : Form
    {

        // Constants

        // Used as measure of comparison
        private const float default_mdl_real_nerve_r = 750; // um
        private float mdl_real_nerve_r = default_mdl_real_nerve_r;
        private const int mdl_real_num_axons = 1200000;
        private const float default_mdl_clearence = 0.2F;
        private float mdl_clearance = default_mdl_clearence; // um
        private const float default_mdl_vessel_ratio = 0.1F; // 0 - 1
        private float mdl_vessel_ratio = default_mdl_vessel_ratio;

        private const float axon_min_r = 0.4F / 2;
        //private const float axon_max_r = 6.87F / 2;
        //private const float axon_min_r_mean = 0.92F / 2;
        private const float axon_max_r_mean = 1.28F / 2;
        private const string fileDirPrefix = @"../../../../Matlab\pdf_from_graph\";
        private string axon_radius_cdf_file = fileDirPrefix + "axon_radius_cdf.tbl";
        private string axon_mean_radius_file = fileDirPrefix + "axon_mean_radius.tbl";
        private const string default_bmp_file = "on-1500.bmp";
        private string axon_bmp_file = fileDirPrefix + default_bmp_file;

        private bool show_axon_order_mdl_gen = false;
        private Bitmap axon_background;
        private const float magicNumber = 1234567f;

        // ===================================================================
        //          reading CDF and Mean tables generated by Matlab
        // ===================================================================
        private uint axon_mean_r_table_grid_siz;
        private float[,] axon_mean_r_table;
        private float[,] axon_cdf_table;
        private float[] axon_cdf_table_radius;
        private uint axon_cdf_table_num_dia, axon_cdf_table_num_prob;

        // Random Generator
        private Random random = new Random();

        private float Get_axon_radius(float x, float y, bool strict_mdl_flg)
        {
            uint x_idx = (uint)((x / mdl_nerve_r + 1) * ((float)axon_mean_r_table_grid_siz / 2F)),
                 y_idx = (uint)((y / mdl_nerve_r + 1) * ((float)axon_mean_r_table_grid_siz / 2F));
            if (x_idx >= axon_mean_r_table_grid_siz) x_idx = axon_mean_r_table_grid_siz - 1;
            if (y_idx >= axon_mean_r_table_grid_siz) y_idx = axon_mean_r_table_grid_siz - 1;

            float r_mean = axon_mean_r_table[x_idx, y_idx];

            if (strict_mdl_flg) return r_mean;

            for (x_idx = 0; x_idx < axon_cdf_table_num_dia; x_idx++)
                if (axon_cdf_table_radius[x_idx] > r_mean) break;
            if (x_idx >= axon_cdf_table_num_dia) x_idx = axon_cdf_table_num_dia - 1;

            float radius = float.NaN;
            while (float.IsNaN(radius)) {
                y_idx = (uint)(random.NextDouble() * (double)axon_cdf_table_num_prob);
                radius = axon_cdf_table[x_idx, y_idx];
            }
            /**
            if(radius < axon_min_r)
            {
                radius = axon_min_r;
            }
            */
            return radius;
        }

        private void Load_Background_Bitmap()
        {
            if (File.Exists(axon_bmp_file))
            {
                axon_background = new Bitmap(axon_bmp_file);
            }
            else
                Append_stat_ln("on-1500.bmp file could not be found.");
        }

        private void Load_mdl_mean_r_table()
        {
            if (File.Exists(axon_mean_radius_file))
            {
                using (BinaryReader reader = new BinaryReader(File.Open(axon_mean_radius_file, FileMode.Open)))
                {
                    axon_mean_r_table_grid_siz = reader.ReadUInt32();
                    axon_mean_r_table = new float[axon_mean_r_table_grid_siz, axon_mean_r_table_grid_siz];

                    for (int radius = 0; radius < axon_mean_r_table_grid_siz; radius++)
                        for (int c = 0; c < axon_mean_r_table_grid_siz; c++)
                            axon_mean_r_table[radius, c] = reader.ReadSingle();
                }
            }
            else
                Append_stat_ln("axon_mean_radius_file could not be found.");
        }

        private void Load_mdl_cdf_table()
        {
            if (File.Exists(axon_radius_cdf_file))
            {
                using (BinaryReader reader = new BinaryReader(File.Open(axon_radius_cdf_file, FileMode.Open)))
                {
                    axon_cdf_table_num_dia = reader.ReadUInt32();
                    axon_cdf_table_num_prob = reader.ReadUInt32() - 1;
                    axon_cdf_table = new float[axon_cdf_table_num_dia, axon_cdf_table_num_prob];
                    axon_cdf_table_radius = new float[axon_cdf_table_num_dia];

                    for (int radius = 0; radius < axon_cdf_table_num_dia; radius++)
                        axon_cdf_table_radius[radius] = reader.ReadSingle();
                    for (int c = 0; c < axon_cdf_table_num_prob; c++)
                        for (int radius = 0; radius < axon_cdf_table_num_dia; radius++)
                            axon_cdf_table[radius, c] = reader.ReadSingle();
                }
            }
            else
                Append_stat_ln("axon_radius_cdf_file could not be found.");
        }

        // ===================================================================
        //                  Model Generation using Circle Packing
        // ===================================================================

        private float mdl_nerve_r = 0;

        [Serializable]
        public class Model
        {
            public float real_diameter; // real diameter in um
            public float nerve_scale_ratio;
            public float vessel_ratio;
            public float clearance;

            public int n_axons;
            public List<float[]> axon_coor;
        }
        public void Save_mdl(string filePath)
        {
            var fs = new FileStream(filePath, FileMode.Append, FileAccess.Write);
            var b = new BinaryWriter(fs);

            b.Write(magicNumber);
            b.Write(mdl.real_diameter);
            b.Write(mdl.nerve_scale_ratio);
            b.Write(mdl.vessel_ratio);
            b.Write(mdl.clearance);
            b.Write(mdl.n_axons);
            for (int k = 0; k < mdl.n_axons; k++)
                for (int i = 0; i < 3; i++)
                    b.Write(mdl.axon_coor[k][i]);
            fs.Close();
        }
        public void Load_mdl(string filePath)
        {
            var fs = new FileStream(filePath, FileMode.Open);
            BinaryReader b = new BinaryReader(fs);

            model_id = B36toDec(Path.GetFileName(filePath).Split(' ')[0]);
            Debug.WriteLine(model_id);

            float firstValue = b.ReadSingle();

            if(firstValue == magicNumber)
            {
                mdl.real_diameter = b.ReadSingle();
                mdl.nerve_scale_ratio = b.ReadSingle();
                mdl.vessel_ratio = b.ReadSingle();
                mdl.clearance = b.ReadSingle();
            }
            else
            {
                mdl.nerve_scale_ratio = firstValue;
                mdl.real_diameter = default_mdl_real_nerve_r * 2;
                mdl.vessel_ratio = default_mdl_vessel_ratio;
                mdl.clearance = default_mdl_clearence;
            }
            
            mdl.n_axons = b.ReadInt32();
            mdl.axon_coor = new List<float[]>();
            for (int k = 0; k < mdl.n_axons; k++)
            {
                float[] coor = new float[3];
                for (int i = 0; i < 3; i++)
                    coor[i] = b.ReadSingle();
                mdl.axon_coor.Add(coor);
            }
            fs.Close();
        }

        

        private float x0 = 0, y0 = 0, r, r1 = 0; // in length unit
        private float x2 = 0, x1 = 0, y2 = 0, y1 = 0; // in length unit
        private float angle = 0;
        private int xc = 0, yc = 0, rc = 0; // in pixels
        private int rc_clear, rc_clear2, rc2, box_x0, box_y0, box_x1, box_y1;
        private float mdl_resolution;
        private bool[,] mdl_occupied_pix;
        private List<float[]> mdl_axons_coor;
        private int mdl_n_axons;
        private AxonLabelClass[] mdl_axon_lbl;


        // takes Xc, Yc and Rc and updates all pixel-based params
        private void Update_box()
        {
            xc = Cor_to_pix(x0);
            yc = Cor_to_pix(y0);
            rc = (int)(r * mdl_resolution);
            rc2 = rc * rc;

            rc_clear = rc + (int)(mdl_clearance * mdl_resolution);
            rc_clear2 = (rc_clear - 1) * (rc_clear - 1);
            box_x0 = Max(xc - rc_clear, 0);
            box_y0 = Max(yc - rc_clear, 0);
            box_x1 = Min(xc + rc_clear + 1, im_size);
            box_y1 = Min(yc + rc_clear + 1, im_size);
        }

        private bool Check_overlap()
        {
            for (int y = box_y0; y < box_y1; y++)
                for (int x = box_x0; x < box_x1; x++)
                {
                    float dx = x - xc;
                    float dy = y - yc;
                    if (rc_clear2 - (dx * dx + dy * dy) >= 0)
                        if (mdl_occupied_pix[x, y])
                            return true;
                }
            return false;
        }

        private int Cor_to_pix(float X)
        {
            return (int)((X + mdl_nerve_r) * mdl_resolution);
        }

        private void New_model()
        {
            // new_model is resolution independent. Numbers are in length unit.

            Load_mdl_mean_r_table();
            Load_mdl_cdf_table();
            
            bool useBack = checkBox_Back_Image.Checked;

            if(useBack == true)
                Load_Background_Bitmap();

            mdl_nerve_r = mdl.nerve_scale_ratio * mdl_real_nerve_r;

            mdl.real_diameter = mdl_real_nerve_r * 2;
            mdl.vessel_ratio = mdl_vessel_ratio;
            mdl.clearance = mdl_clearance;

            sim_stat = Sim_stat_enum.Running;

            mdl_axons_coor = new List<float[]>();
            mdl_n_axons = 0;
           // mdl.n_axons = 0;

            bool strict_mdl_flg = false;

            Update_bottom_stat("Generating Model...");

            mdl_resolution = 25; // Resolution of image during model generation

            im_size = (ushort)(mdl_nerve_r * 2 * mdl_resolution);

            mdl_occupied_pix = new bool[im_size, im_size];

            x0 = 0; y0 = 0; x2 = 0; x1 = 0; y2 = 0; y1 = 0; r1 = 0;
            angle = 0;

            float angle_step = 0.08F;
            float distance_step = mdl_clearance / 2;

            Tic();

            int num_tries = (int)(3 * mdl_nerve_r * mdl_nerve_r);

            for (int i = 0; i < num_tries; i++)
            {
                // =================================

                if (i % 20 == 0) Update_mdl_prog((float)i / num_tries);

                r = Get_axon_radius(x1, y1, strict_mdl_flg);

                if (i > 0)
                {
                    float dist = r + r1 + mdl_clearance;
                    x0 = x1 + (float)Math.Cos(angle) * dist;
                    y0 = y1 + (float)Math.Sin(angle) * dist;

                    if (i > 1)
                    {
                        bool intitial_overlap = true;
                        float Xcg = 0, Ycg = 0; // last successful coords
                        float angle_init = angle;
                        while (true)
                        {
                            x0 = x1 + (float)Math.Cos(angle) * dist;
                            y0 = y1 + (float)Math.Sin(angle) * dist;

                            Update_box();
                            if (Check_overlap())
                            {
                                if (intitial_overlap)
                                {
                                    angle -= angle_step;
                                    if (Math.Abs(angle - angle_init) >= Math.PI)
                                    {
                                        dist += distance_step;
                                        angle = angle_init;
                                    }
                                }
                                else
                                {
                                    // revert to the last non-overlapping case
                                    x0 = Xcg;
                                    y0 = Ycg;
                                    angle -= angle_step;
                                    break;
                                }
                            }
                            else
                            {
                                intitial_overlap = false;
                                Xcg = x0;
                                Ycg = y0;
                                angle += angle_step;
                            }
                        }
                    }
                }

                Update_box();

                // Add neuron
                for (int y = box_y0; y < box_y1; y++)
                    for (int x = box_x0; x < box_x1; x++)
                        if (Within_circle2(x, y, xc, yc, rc) > 0)
                            mdl_occupied_pix[x, y] = true;
                int xpix = (int)((mdl_nerve_r + x0)/ mdl.nerve_scale_ratio);
                if (xpix >= 1500) xpix = 1499;
                int ypix = (int)((mdl_nerve_r + y0)/ mdl.nerve_scale_ratio);
                if (ypix >= 1500) ypix = 1499;
                if (useBack== true && axon_background != null)
                {
                    Color clr = axon_background.GetPixel(xpix > 0 ? xpix : 0, ypix > 0 ? ypix : 0);
                    //Append_stat_ln(clr.R.ToString() + " " + clr.G.ToString() + " " + clr.B.ToString());
                    if (clr.R < 128 && clr.G < 128 && clr.B < 128)
                    {
                        mdl_axons_coor.Add(new float[3] { x0, y0, r });
                        mdl_n_axons++;
                    }
                }
                else
                {
                    mdl_axons_coor.Add(new float[3] { x0, y0, r });
                    mdl_n_axons++;
                }

                if (i % 10 == 0) Update_num_axons_lbl();

                x2 = x1; x1 = x0;
                y2 = y1; y1 = y0;
                r1 = r;

            }
            mdl.axon_coor = new List<float[]>();
            mdl.n_axons = 0;

            if (show_axon_order_mdl_gen)
                mdl_axon_lbl = new AxonLabelClass[mdl_n_axons];

            int idx = 0;
            for (int i = 0; i < mdl_n_axons; i++)
            {
                float cent_dis = (float)Math.Sqrt(mdl_axons_coor[i][0] * mdl_axons_coor[i][0] +
                    mdl_axons_coor[i][1] * mdl_axons_coor[i][1]);
                if (cent_dis + mdl_axons_coor[i][2] > mdl_nerve_r) continue;
                if (cent_dis - mdl_axons_coor[i][2] < mdl_vessel_ratio * mdl_nerve_r) continue;

                mdl.axon_coor.Add(mdl_axons_coor[i]);
                mdl.n_axons++;

                int mdl_gen_im_siz = im_size = Calc_im_siz();

                if (show_axon_order_mdl_gen)
                {
                    float tempx = mdl_axons_coor[i][0] * setts.resolution_xy + mdl_gen_im_siz / 2;
                    float tempy = mdl_axons_coor[i][1] * setts.resolution_xy + mdl_gen_im_siz / 2;
                    mdl_axon_lbl[idx] = new AxonLabelClass { lbl = (i + 1).ToString("0"), x = tempx, y = tempy };
                    idx++;
                }
            }

            model_id = DateTime.Now.Ticks / 1000;
            model_is_saved = false;
            sim_stat = Sim_stat_enum.None;
            Update_mdl_prog((float)1);
            Append_stat("Model Generated in " + (Toc() / 1000).ToString("0.0") + " secs\n");
            Append_stat("Press Preprocess to show generated model.\n");
            Debug.WriteLine("model done");
            Update_num_axons_lbl();
            

            //Preprocess_model();
        }
    }
}

/*
float sample_radius_obsolete(float x, float y, bool strict_mdl_flg)
{
    float r_mean = axon_min_r_mean + (x + mdl.nerve_r) / (mdl.nerve_r * 2) * (axon_max_r_mean - axon_min_r_mean);

    if (strict_mdl_flg) return r_mean;

    double alpha = 3;
    double beta = (r_mean - axon_min_r) / (axon_max_r - axon_min_r) * (alpha - 1);
    //double nrm_rnd = (1 / Gamma.Sample(alpha, 1 / beta));
    float r;
    do
    {
        //MathNet.Numerics.Distributions.Normal
        double samp = InverseGamma.Sample(alpha, beta);
        //double samp = 1 / Gamma.Sample(alpha, 1 / beta);
        r = (float)(axon_min_r + samp * (axon_max_r - axon_min_r));
    }
    while (r >= axon_max_r);

    return r;
}
*/
